/*
 * Mabel Luo
   December 15, 2019
 * A program that implements four different sorting algorithms and tests their 
 * respective efficiencies about the number of loops and number of milliseconds.
 * Two test datasets are used, which consist of ten and ten thousand random numbers
 */
package luosortingefficiencies;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.text.DecimalFormat;
import javax.swing.JOptionPane;
import java.util.ArrayList;

/**
 *
 * @author PCPCPC
 */
public class LuoSortingEfficiencies extends javax.swing.JFrame {

    /**
     * Creates new form LuoSortingEfficiencies
     */
    //Declare two arrays to store the initial datasets of random numbers
    int[] tenNum = new int[10];
    int[] tenKNum = new int[10000];
    
    //Declare and initialize variables that calculate the times to sort
    //the test datasets, as well as the number of loops to complete the work
    long elapsedSelection = 0;
    long elapsedBubble = 0;
    long elapsedInsertion = 0;
    long elapsedQuick = 0;

    int numLoopsSelection = 0;
    int numLoopsBubble = 0;
    int numLoopsInsertion = 0;
    int numLoopsQuick = 0;
    //Declare a variable to store the user choice on whether the sort is on ascending 
    //or descending order
    String order;
    
    public LuoSortingEfficiencies() {
        initComponents();
        //Read the external text files and store them in two arrays as the original
        //datasets
        tenNum = readNumbers(10);
        tenKNum = readNumbers(10000);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnGrpAmtOfNum = new javax.swing.ButtonGroup();
        btnGrpSortOrder = new javax.swing.ButtonGroup();
        lblTitle = new javax.swing.JLabel();
        lblAmtNum = new javax.swing.JLabel();
        rdBtn10 = new javax.swing.JRadioButton();
        rdBtn10000 = new javax.swing.JRadioButton();
        lblSortedBy = new javax.swing.JLabel();
        cBoxSortedBy = new javax.swing.JComboBox<>();
        lblSortOrder = new javax.swing.JLabel();
        rdBtnAsc = new javax.swing.JRadioButton();
        rdBtnDsc = new javax.swing.JRadioButton();
        btnSort = new javax.swing.JButton();
        lblOriginalNum = new javax.swing.JLabel();
        lblSortedNum = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtOriginalNum = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtSortedNum = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        txtResults = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        lblTitle.setFont(new java.awt.Font("宋体", 1, 14)); // NOI18N
        lblTitle.setText("Sorting Efficiencies");

        lblAmtNum.setText("Amount of numbers to sort:");

        btnGrpAmtOfNum.add(rdBtn10);
        rdBtn10.setText("10");
        rdBtn10.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdBtn10ActionPerformed(evt);
            }
        });

        btnGrpAmtOfNum.add(rdBtn10000);
        rdBtn10000.setText("10,000");

        lblSortedBy.setText("Display numbers sorted by:");

        cBoxSortedBy.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Selection Sort", "Bubble Sort", "Insertion Sort", "Quick Sort" }));

        lblSortOrder.setText("Sort order:");

        btnGrpSortOrder.add(rdBtnAsc);
        rdBtnAsc.setText("Ascending");

        btnGrpSortOrder.add(rdBtnDsc);
        rdBtnDsc.setText("Descending");

        btnSort.setFont(new java.awt.Font("宋体", 0, 14)); // NOI18N
        btnSort.setText("Sort");
        btnSort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSortActionPerformed(evt);
            }
        });

        lblOriginalNum.setText("Original Numbers:");

        lblSortedNum.setText("Sorted Numbers:");

        txtOriginalNum.setColumns(20);
        txtOriginalNum.setRows(5);
        jScrollPane1.setViewportView(txtOriginalNum);

        txtSortedNum.setColumns(20);
        txtSortedNum.setRows(5);
        jScrollPane2.setViewportView(txtSortedNum);

        txtResults.setColumns(20);
        txtResults.setRows(5);
        jScrollPane3.setViewportView(txtResults);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(54, 54, 54)
                        .addComponent(lblTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(lblSortOrder, javax.swing.GroupLayout.PREFERRED_SIZE, 74, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(rdBtnDsc)
                                            .addComponent(rdBtnAsc)))
                                    .addComponent(lblOriginalNum, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(lblSortedNum, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jScrollPane2)
                                    .addComponent(btnSort, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 346, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(lblAmtNum)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(rdBtn10)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(rdBtn10000)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(lblSortedBy, javax.swing.GroupLayout.PREFERRED_SIZE, 165, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(cBoxSortedBy, javax.swing.GroupLayout.PREFERRED_SIZE, 119, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 316, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                .addGap(29, 29, 29))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addComponent(lblTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblAmtNum)
                    .addComponent(rdBtn10)
                    .addComponent(rdBtn10000))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblSortedBy, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(cBoxSortedBy, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(lblSortOrder, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(rdBtnAsc))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(rdBtnDsc))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(20, 20, 20)
                                .addComponent(btnSort, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(8, 8, 8)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblOriginalNum, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblSortedNum, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 188, Short.MAX_VALUE)
                            .addComponent(jScrollPane2)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(17, 17, 17)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(34, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    private int[] readNumbers(int num){
        //The method that loads the random numbers from an external text file
        //This method is copied from Mr. Cutten's example with some modifications
        //It can read and load both external files based on the parameter received
        String sNumber;
        int number;
        int[] temp = new int[num];
        
            //to open a connection to the external file
        try {
            FileReader fr = new FileReader("src\\luosortingefficiencies\\" + num + "nums.txt");
            BufferedReader br = new BufferedReader(fr);
            //loop until we reach the end of the file
            for(int i = 0; i < num; i++) {
                //read one line
                sNumber = br.readLine();
                number = Integer.parseInt(sNumber);
                //Add the number to the array
                temp[i] = number;
                }
            //close the connection
            br.close();
            }
        catch (IOException e) {
            //there was an exception, so print it out for all to see
            System.out.println("Error: " + e);
        }
        catch (NumberFormatException e){
            //Exception to catch the input format problem
            JOptionPane.showMessageDialog(this,"All number should be integers!");
        }
        return temp;
    }
    
    private int[] selectionSortA(int[] myTemp){
        //The method that receives an array and returns with a sorted array.
        //It implements the selection sort algorithm with ascending order
        int temp;
        for (int i =0; i < myTemp.length; i++){//Outer loop
            for (int j = i + 1; j < myTemp.length; j++){//Inner loop
                numLoopsSelection++;
                if (myTemp[i] > myTemp[j] ){
                    //Compare inner and outer loops, if the outer is greater than
                    //the inner, then swap them
                    temp = myTemp[i];
                    myTemp[i] = myTemp[j];
                    myTemp[j] = temp;
                }
            }
        }
        return myTemp;
    }
    
    private int[] selectionSortD(int[] myTemp){
        //The method that receives an array and returns with a sorted array.
        //It implements the selection sort algorithm with descending order
        int temp;
        for (int i =0; i < myTemp.length; i++){//Outer loop
            for (int j = i + 1; j < myTemp.length; j++){//Inner loop
                numLoopsSelection++;
                if (myTemp[i] < myTemp[j] ){
                    //Compare inner and outer loops, if the outer is less than
                    //the inner, then swap them
                    temp = myTemp[i];
                    myTemp[i] = myTemp[j];
                    myTemp[j] = temp;
                }
            }
        }
        return myTemp;
    }
    
    private int[] bubbleSortA(int[] myTemp) {
        //The method that receives an array and returns with a sorted array.
        //It implements the bubble sort algorithm with ascending order
        int temp;
        boolean sw = true;
        int bottom = myTemp.length - 1;
        while (sw) {
            sw = false;
            for (int i = 0; i < bottom; i++){
                numLoopsBubble++;
                if(myTemp[i] > myTemp[i+1]) {
                    //Compare to next element, if it's greater than the next one,
                    //then swap them
                    sw = true;
                    temp = myTemp[i];
                    myTemp[i] = myTemp[i+1];
                    myTemp[i+1] = temp;
                }
            }
            bottom--;
        }
        return myTemp;
    }
    
    private int[] bubbleSortD(int[] myTemp) {
        //The method that receives an array and returns with a sorted array.
        //It implements the bubble sort algorithm with descending order
        int temp;
        boolean sw = true;
        int bottom = myTemp.length - 1;
        while (sw) {
            sw = false;
            for (int i = 0; i < bottom; i++){
                numLoopsBubble++;
                if(myTemp[i] < myTemp[i+1]) {
                    //Compare to next element, if it's less than the next one,
                    //then swap them
                    sw = true;
                    temp = myTemp[i];
                    myTemp[i] = myTemp[i+1];
                    myTemp[i+1] = temp;
                }
            }
            bottom--;
        }
        return myTemp;
    }
    
    private int[] insertionSortA(int[] myTemp){
        //The method that receives an array and returns with a sorted array.
        //It implements the insertion sort algorithm with ascending order
        int temp, j;
        for (int i = 1; i < myTemp.length; i++){//Outer loop which starts with 
            //A[1], up to the last element
            temp = myTemp[i];//store the outer loop element to a temporary variable
            j = i - 1;
            while (j >= 0 && myTemp[j] > temp) {//Inner loop
                //Compare the temporary variable to the elements whose index is 
                //less than the outer loop index. If the inner is greater than temp
                //then move up one position until the inner is no longer greater than
                //temp
                numLoopsInsertion++;
                myTemp[j+1] = myTemp[j];
                j--;
            }
            myTemp[j+1] = temp;//Insert the moved up position with the outer
        }
        return myTemp;
    }
    
    private int[] insertionSortD(int[] myTemp){
        //The method that receives an array and returns with a sorted array.
        //It implements the insertion sort algorithm with descending order
        int temp, j;
        for (int i = 1; i < myTemp.length; i++){//Outer loop which starts with 
            //A[1], up to the last element
            temp = myTemp[i]; //store the outer loop element to a temporary variable
            j = i - 1;
            while (j >= 0 && myTemp[j] < temp) {//Inner loop
                //Compare the temporary variable to the elements whose index is 
                //less than the outer loop index. If the inner is less than temp
                //then move up one position until the inner is no longer less than
                //temp
                numLoopsInsertion++;
                myTemp[j+1] = myTemp[j];
                j--;
            }
            myTemp[j+1] = temp; //Insert the moved up position with the outer
        }
        return myTemp;
    }
    
    private int[] quickSortA(int[] myTemp, int left, int right) {
        //The method that receives an array and returns with a sorted array.
        //It implements the quich sort algorithm with ascending order
        //This method is copied from Mr. Cutten's example with a few modifications
        if (left >= right) {
            return myTemp;
        }
        int i = left;
        int j = right;
        // Get the pivot element from the middle of the list
        int pivot = myTemp[((left + right) / 2)];
        // Divide into two lists - Partition
        while (i < j) {
            // If the current value from the left list is smaller than the pivot
            // element, then get the next element from the left list
            while (myTemp[i] < pivot) {
                numLoopsQuick++;
                i++;
            }
            // If the current value from the right list is larger than the pivot
            // element, then get the next element from the right list
            while (myTemp[j] > pivot) {
                numLoopsQuick++;
                j--;
            }
            // If we have found a value in the left list which is larger than
            // the pivot element and if we have found a value in the right list
            // which is smaller than the pivot element, then we exchange the
            // values. 
            if (i <= j) {
                int temp = myTemp[i];
                myTemp[i] = myTemp[j];
                myTemp[j] = temp; 
                // As we are done we can increase i and decrease j
                i++;
                j--;
            }
        }
        // Recursion
        quickSortA(myTemp, left, j); //sort the left side of the list
        quickSortA(myTemp, i, right); //sort the right side of the list
        return myTemp;
    }
    
    private int[] quickSortD(int[] myTemp, int left, int right) {
        //The method that receives an array and returns with a sorted array.
        //It implements the quick sort algorithm with descending order.
        //This method is copied from Mr. Cutten's example with a few modifications
        if (left >= right) {
            return myTemp;
        }
        int i = left;
        int j = right;
        // Get the pivot element from the middle of the list
        int pivot = myTemp[((left + right) / 2)];
        // Divide into two lists - Partition
        while (i < j) {
            // If the current value from the left list is smaller than the pivot
            // element then get the next element from the left list
            while (myTemp[i] > pivot) {
                numLoopsQuick++;
                i++;
            }
            // If the current value from the right list is larger than the pivot
            // element then get the next element from the right list
            while (myTemp[j] < pivot) {
                numLoopsQuick++;
                j--;
            }
            // If we have found a value in the left list which is larger than
            // the pivot element and if we have found a value in the right list
            // which is smaller than the pivot element, then we exchange the
            // values. 
            if (i <= j) {
                int temp = myTemp[i];
                myTemp[i] = myTemp[j];
                myTemp[j] = temp; 
                // As we are done we can increase i and decrease j
                i++;
                j--;
            }
        }
        // Recursion
        quickSortD(myTemp, left, j); //sort the left side of the list
        quickSortD(myTemp, i, right); //sort the right side of the list
        return myTemp;
    }
    
    private void rdBtn10ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdBtn10ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_rdBtn10ActionPerformed

    private void btnSortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSortActionPerformed
        //The method performs after the "Sort" button is clicked
        //It runs different sorting based on user's choices using four sort algorithms 
        
        //Declare and initialize the variable that stores which sorting algorithm
        //is used to display the numbers. They will be integers 0 to 3 representing
        //selection, bubble, insertion, and quick.
        int display = cBoxSortedBy.getSelectedIndex();
        
        //Reset the variables that record the number of loops because the user could
        //run multiple tests. They should be reset to zero before each test
        reset();
        
        //The user's choices must be one of following four scenarios:
        //10A, 10D, 10000A and 10000D. Otherwise, they must have missed one of options
        //to choose either the datasets, or order. If the user misses, it will 
        //pop up an message to show the error.
        //Once the choice is one of them, it invokes the testSortingEff() method
        //to perform the testing
        if (rdBtn10.isSelected() && rdBtnAsc.isSelected()){
            //10A
            order = "A";
            testSortingEff(tenNum, order, display);
        }
        else if (rdBtn10.isSelected() && rdBtnDsc.isSelected()){
            //10D
            order = "D";
            testSortingEff(tenNum, order, display);
        }
        else if (rdBtn10000.isSelected() && rdBtnAsc.isSelected()){
            //10000A
            order = "A";
            testSortingEff(tenKNum, order, display);
        }
        else if (rdBtn10000.isSelected() && rdBtnDsc.isSelected()){
            //10000D
            order = "D";
            testSortingEff(tenKNum, order, display);
        }
        else{
            JOptionPane.showMessageDialog(this,"Please choose all options!");
        }

    }//GEN-LAST:event_btnSortActionPerformed

    private void reset(){
        //Reset the variables that record the number of loops because the user could
        //run multiple tests. The variables should be reset to zero before each test
        numLoopsSelection = 0;
        numLoopsBubble = 0;
        numLoopsInsertion = 0;
        numLoopsQuick = 0;
    }
    private void testSortingEff(int[] dataSet, String order, int display){
        //The method that receives the original dataset, the order, and which sort
        //algorithm is used to display the number. 
        //It then performs four different sorts and records the time used. 
        
        //Declare an array to store the sorted result
        int[] arraySorted = new int[dataSet.length];
        //Declare the variable to store the system time before and after a process
        long start, finish;
        //Declare an ArrayList to store sorted arrays in order to display the numbers
        ArrayList<int[]> myList = new ArrayList();
        
        //Two scenarios based on "order" because the sorting methods are implemented
        //separately with respect to ascending or descending order
        if (order.equals("D")) {
            //Sorts the cloned original dataset and records the time used. The 
            //sorted array will be added to the ArrayList
            
            //Selection descending order
            start = System.currentTimeMillis();
            arraySorted = selectionSortD(dataSet.clone());
            finish = System.currentTimeMillis();
            elapsedSelection = finish - start;
            myList.add(arraySorted);
            
            //Bubble descending order
            start = System.currentTimeMillis();
            arraySorted = bubbleSortD(dataSet.clone());
            finish = System.currentTimeMillis();
            elapsedBubble = finish - start;
            myList.add(arraySorted);
            
            //Insertion descending order
            start = System.currentTimeMillis();
            arraySorted = insertionSortD(dataSet.clone());
            finish = System.currentTimeMillis();
            elapsedInsertion = finish - start;
            myList.add(arraySorted);
            
            //Quick descending order
            start = System.currentTimeMillis();
            arraySorted = quickSortD(dataSet.clone(), 0, dataSet.length - 1);
            finish = System.currentTimeMillis();
            elapsedQuick = finish - start;
            myList.add(arraySorted);
        }
        else {
            start = System.currentTimeMillis();
            arraySorted = selectionSortA(dataSet.clone());
            finish = System.currentTimeMillis();
            elapsedSelection = finish - start;
            myList.add(arraySorted);
            
            start = System.currentTimeMillis();
            arraySorted = bubbleSortA(dataSet.clone());
            finish = System.currentTimeMillis();
            elapsedBubble = finish - start;
            myList.add(arraySorted);
            
            start = System.currentTimeMillis();
            arraySorted = insertionSortA(dataSet.clone());
            finish = System.currentTimeMillis();
            elapsedInsertion = finish - start;
            myList.add(arraySorted);
            
            start = System.currentTimeMillis();
            arraySorted = quickSortA(dataSet.clone(), 0, dataSet.length - 1);
            finish = System.currentTimeMillis();
            elapsedQuick = finish - start;
            myList.add(arraySorted);
        }
        //Display the sorted numbers in text area based on user's input on which
        //sorting algorithm is used to display
        displayNums(myList.get(display));
        //Display the test results in text area
        displayResults();
    }
    
    private void displayNums(int[] sortedArray){
        //Display the sorted numbers in text area based on user's input on which
        //sorting algorithm is used to display. It displays the original datasets
        //as well.
        String outputOriginal = "";
        String outputSorted = "";
        for(int i = 0; i < sortedArray.length; i++){
            if (sortedArray.length == 10) {
                outputOriginal = outputOriginal + i + ": " + tenNum[i] + "\n";
            } else {
                outputOriginal = outputOriginal + i + ": " + tenKNum[i] + "\n";
            }
                outputSorted = outputSorted +  i + ": " + sortedArray[i] + "\n";
            }
            txtOriginalNum.setText(outputOriginal);
            txtSortedNum.setText(outputSorted);
    }
    
    private void displayResults(){
        //Display the test results for all four sorting algorithms
        String results, numLoops, numMS;
        numLoops = "Number of times a loop was executed: ";
        numMS = "Number of milliseconds to complete sort: ";
        DecimalFormat myFormat = new DecimalFormat("#,##0");

        results = "Selection Sort:" + "\n" +
                numLoops + myFormat.format(numLoopsSelection) + "\n" +
                numMS + elapsedSelection + "\n" +
                "Bubble Sort:" + "\n" +
                numLoops + myFormat.format(numLoopsBubble) + "\n" +
                numMS + elapsedBubble+ "\n" +
                "Insertion Sort:" + "\n" +
                numLoops + myFormat.format(numLoopsInsertion) + "\n" +
                numMS + elapsedInsertion + "\n" +
                "Quick Sort:" + "\n" +
                numLoops + myFormat.format(numLoopsQuick) + "\n" +
                numMS + elapsedQuick + "\n";
            
        txtResults.setText(results);
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(LuoSortingEfficiencies.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(LuoSortingEfficiencies.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(LuoSortingEfficiencies.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(LuoSortingEfficiencies.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new LuoSortingEfficiencies().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup btnGrpAmtOfNum;
    private javax.swing.ButtonGroup btnGrpSortOrder;
    private javax.swing.JButton btnSort;
    private javax.swing.JComboBox<String> cBoxSortedBy;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JLabel lblAmtNum;
    private javax.swing.JLabel lblOriginalNum;
    private javax.swing.JLabel lblSortOrder;
    private javax.swing.JLabel lblSortedBy;
    private javax.swing.JLabel lblSortedNum;
    private javax.swing.JLabel lblTitle;
    private javax.swing.JRadioButton rdBtn10;
    private javax.swing.JRadioButton rdBtn10000;
    private javax.swing.JRadioButton rdBtnAsc;
    private javax.swing.JRadioButton rdBtnDsc;
    private javax.swing.JTextArea txtOriginalNum;
    private javax.swing.JTextArea txtResults;
    private javax.swing.JTextArea txtSortedNum;
    // End of variables declaration//GEN-END:variables
}
